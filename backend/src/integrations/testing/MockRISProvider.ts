/**
 * Mock RIS Provider for Testing
 * Simulates Voyager RIS responses for integration testing
 */

import { 
  BaseRISProvider, 
  RISConnectionConfig, 
  RISQuery, 
  RISOperationResult,
  Patient,
  Order,
  Report,
  Schedule,
  HL7Message 
} from '../interfaces/IRISProvider';
import { Logger } from '../../utils/logger';

export interface MockRISConfig {
  simulateLatency: boolean;
  latencyRange: { min: number; max: number };
  errorRate: number;
  simulateHL7Issues: boolean;
  mockDataSet: 'minimal' | 'comprehensive' | 'large';
  enableWebhooks: boolean;
  simulateWorkflowUpdates: boolean;
  generateReports: boolean;
}

export class MockRISProvider extends BaseRISProvider {
  readonly name = 'Mock RIS Provider';
  readonly version = '1.0.0';
  readonly vendor = 'Axis Imaging Test';
  
  private logger: Logger;
  private mockConfig: MockRISConfig;
  private mockPatients: Patient[] = [];
  private mockOrders: Order[] = [];
  private mockReports: Report[] = [];
  private mockSchedule: Schedule[] = [];
  private connectionStartTime?: Date;
  private messageSequence: number = 1;
  
  constructor(mockConfig: MockRISConfig = {
    simulateLatency: true,
    latencyRange: { min: 100, max: 1500 },
    errorRate: 0.03,
    simulateHL7Issues: false,
    mockDataSet: 'comprehensive',
    enableWebhooks: false,
    simulateWorkflowUpdates: true,
    generateReports: true
  }) {
    super();
    this.logger = new Logger('MockRISProvider');
    this.mockConfig = mockConfig;
    this.initializeMockData();
  }
  
  async connect(config: RISConnectionConfig): Promise<RISOperationResult<boolean>> {
    const operationId = this.generateOperationId();
    this.logger.info(`Mock RIS connecting to: ${config.endpoint}`);
    
    try {
      await this.simulateLatency();
      
      // Simulate HL7 connection issues
      if (this.mockConfig.simulateHL7Issues && Math.random() < 0.1) {
        throw new Error('HL7 connection refused');
      }
      
      // Simulate authentication
      if (config.authentication) {
        await this.simulateLatency(300);
        if (config.authentication.credentials.username === 'invalid') {
          throw new Error('Invalid credentials');
        }
      }
      
      this.config = config;
      this.connected = true;
      this.connectionStartTime = new Date();
      
      // Start workflow simulation if enabled
      if (this.mockConfig.simulateWorkflowUpdates) {
        this.startWorkflowSimulation();
      }
      
      this.logger.info('Mock RIS connected successfully');
      return this.createSuccessResult(true, operationId);
      
    } catch (error) {
      this.logger.error('Mock RIS connection failed:', error);
      return this.createErrorResult(error.message, 'CONNECTION_FAILED', operationId);
    }
  }
  
  async disconnect(): Promise<RISOperationResult<boolean>> {
    const operationId = this.generateOperationId();
    
    try {
      await this.simulateLatency(100);
      
      this.connected = false;
      this.connectionStartTime = undefined;
      
      this.logger.info('Mock RIS disconnected');
      return this.createSuccessResult(true, operationId);
      
    } catch (error) {
      return this.createErrorResult(error.message, 'DISCONNECT_ERROR', operationId);
    }
  }
  
  async testConnection(): Promise<RISOperationResult<boolean>> {
    const operationId = this.generateOperationId();
    
    try {
      if (!this.connected) {
        throw new Error('Not connected');
      }
      
      await this.simulateLatency(100);
      
      if (this.shouldSimulateError()) {
        throw new Error('HL7 test message failed');
      }
      
      return this.createSuccessResult(true, operationId);
      
    } catch (error) {\n      return this.createErrorResult(error.message, 'CONNECTION_TEST_FAILED', operationId);\n    }\n  }\n  \n  async findPatients(query: RISQuery): Promise<RISOperationResult<Patient[]>> {\n    const operationId = this.generateOperationId();\n    \n    try {\n      if (!this.connected) {\n        throw new Error('Not connected to RIS');\n      }\n      \n      await this.simulateLatency();\n      \n      if (this.shouldSimulateError()) {\n        throw new Error('Patient search failed - database timeout');\n      }\n      \n      let results = this.mockPatients.filter(patient => {\n        if (query.patientID && !patient.patientID.includes(query.patientID)) {\n          return false;\n        }\n        \n        const fullName = `${patient.firstName} ${patient.lastName}`.toLowerCase();\n        if (query.patientName && !fullName.includes(query.patientName.toLowerCase())) {\n          return false;\n        }\n        \n        return true;\n      });\n      \n      // Apply pagination\n      if (query.offset) {\n        results = results.slice(query.offset);\n      }\n      \n      if (query.limit) {\n        results = results.slice(0, query.limit);\n      }\n      \n      this.logger.debug(`Mock RIS found ${results.length} patients`);\n      return this.createSuccessResult(results, operationId);\n      \n    } catch (error) {\n      this.logger.error('Mock patient search failed:', error);\n      return this.createErrorResult(error.message, 'PATIENT_SEARCH_FAILED', operationId);\n    }\n  }\n  \n  async getPatient(patientID: string): Promise<RISOperationResult<Patient>> {\n    const operationId = this.generateOperationId();\n    \n    try {\n      if (!this.connected) {\n        throw new Error('Not connected to RIS');\n      }\n      \n      await this.simulateLatency();\n      \n      if (this.shouldSimulateError()) {\n        throw new Error('Patient lookup failed');\n      }\n      \n      const patient = this.mockPatients.find(p => p.patientID === patientID);\n      \n      if (!patient) {\n        throw new Error('Patient not found');\n      }\n      \n      return this.createSuccessResult(patient, operationId);\n      \n    } catch (error) {\n      return this.createErrorResult(error.message, 'GET_PATIENT_FAILED', operationId);\n    }\n  }\n  \n  async updatePatient(patient: Patient): Promise<RISOperationResult<boolean>> {\n    const operationId = this.generateOperationId();\n    \n    try {\n      if (!this.connected) {\n        throw new Error('Not connected to RIS');\n      }\n      \n      await this.simulateLatency();\n      \n      if (this.shouldSimulateError()) {\n        throw new Error('Patient update failed - database error');\n      }\n      \n      // Find and update patient\n      const index = this.mockPatients.findIndex(p => p.patientID === patient.patientID);\n      if (index >= 0) {\n        this.mockPatients[index] = patient;\n      } else {\n        this.mockPatients.push(patient);\n      }\n      \n      return this.createSuccessResult(true, operationId);\n      \n    } catch (error) {\n      return this.createErrorResult(error.message, 'PATIENT_UPDATE_FAILED', operationId);\n    }\n  }\n  \n  async findOrders(query: RISQuery): Promise<RISOperationResult<Order[]>> {\n    const operationId = this.generateOperationId();\n    \n    try {\n      if (!this.connected) {\n        throw new Error('Not connected to RIS');\n      }\n      \n      await this.simulateLatency();\n      \n      if (this.shouldSimulateError()) {\n        throw new Error('Order search failed');\n      }\n      \n      let results = this.mockOrders.filter(order => {\n        if (query.patientID && order.patientID !== query.patientID) {\n          return false;\n        }\n        \n        if (query.accessionNumber && order.accessionNumber !== query.accessionNumber) {\n          return false;\n        }\n        \n        if (query.orderID && order.orderID !== query.orderID) {\n          return false;\n        }\n        \n        if (query.status?.length && !query.status.includes(order.status)) {\n          return false;\n        }\n        \n        if (query.modality?.length) {\n          const orderModalities = order.procedures.map(p => p.modality);\n          if (!query.modality.some(m => orderModalities.includes(m))) {\n            return false;\n          }\n        }\n        \n        if (query.dateRange) {\n          const orderDate = new Date(order.orderDate);\n          const fromDate = new Date(query.dateRange.from);\n          const toDate = new Date(query.dateRange.to);\n          \n          if (orderDate < fromDate || orderDate > toDate) {\n            return false;\n          }\n        }\n        \n        if (query.orderingPhysician && \n            !order.orderingPhysician.name.toLowerCase().includes(query.orderingPhysician.toLowerCase())) {\n          return false;\n        }\n        \n        return true;\n      });\n      \n      // Apply pagination\n      if (query.offset) {\n        results = results.slice(query.offset);\n      }\n      \n      if (query.limit) {\n        results = results.slice(0, query.limit);\n      }\n      \n      this.logger.debug(`Mock RIS found ${results.length} orders`);\n      return this.createSuccessResult(results, operationId);\n      \n    } catch (error) {\n      return this.createErrorResult(error.message, 'ORDER_SEARCH_FAILED', operationId);\n    }\n  }\n  \n  async getOrder(orderID: string): Promise<RISOperationResult<Order>> {\n    const operationId = this.generateOperationId();\n    \n    try {\n      const order = this.mockOrders.find(o => o.orderID === orderID);\n      \n      if (!order) {\n        throw new Error('Order not found');\n      }\n      \n      return this.createSuccessResult(order, operationId);\n      \n    } catch (error) {\n      return this.createErrorResult(error.message, 'GET_ORDER_FAILED', operationId);\n    }\n  }\n  \n  async updateOrderStatus(orderID: string, status: string, notes?: string): Promise<RISOperationResult<boolean>> {\n    const operationId = this.generateOperationId();\n    \n    try {\n      if (!this.connected) {\n        throw new Error('Not connected to RIS');\n      }\n      \n      await this.simulateLatency();\n      \n      if (this.shouldSimulateError()) {\n        throw new Error('Order status update failed');\n      }\n      \n      const order = this.mockOrders.find(o => o.orderID === orderID);\n      if (order) {\n        order.status = status as any;\n        \n        // Trigger order update event\n        if (this.onOrderUpdate) {\n          setTimeout(() => {\n            this.onOrderUpdate!(orderID, status);\n          }, 100);\n        }\n      }\n      \n      return this.createSuccessResult(true, operationId);\n      \n    } catch (error) {\n      return this.createErrorResult(error.message, 'ORDER_STATUS_UPDATE_FAILED', operationId);\n    }\n  }\n  \n  async findReports(query: RISQuery): Promise<RISOperationResult<Report[]>> {\n    const operationId = this.generateOperationId();\n    \n    try {\n      if (!this.connected) {\n        throw new Error('Not connected to RIS');\n      }\n      \n      await this.simulateLatency();\n      \n      if (this.shouldSimulateError()) {\n        throw new Error('Report search failed');\n      }\n      \n      let results = this.mockReports.filter(report => {\n        if (query.patientID && report.patientID !== query.patientID) {\n          return false;\n        }\n        \n        if (query.accessionNumber && report.accessionNumber !== query.accessionNumber) {\n          return false;\n        }\n        \n        return true;\n      });\n      \n      // Apply pagination\n      if (query.offset) {\n        results = results.slice(query.offset);\n      }\n      \n      if (query.limit) {\n        results = results.slice(0, query.limit);\n      }\n      \n      return this.createSuccessResult(results, operationId);\n      \n    } catch (error) {\n      return this.createErrorResult(error.message, 'REPORT_SEARCH_FAILED', operationId);\n    }\n  }\n  \n  async getReport(reportID: string): Promise<RISOperationResult<Report>> {\n    const operationId = this.generateOperationId();\n    \n    try {\n      const report = this.mockReports.find(r => r.reportID === reportID);\n      \n      if (!report) {\n        throw new Error('Report not found');\n      }\n      \n      return this.createSuccessResult(report, operationId);\n      \n    } catch (error) {\n      return this.createErrorResult(error.message, 'GET_REPORT_FAILED', operationId);\n    }\n  }\n  \n  async createReport(report: Partial<Report>): Promise<RISOperationResult<string>> {\n    const operationId = this.generateOperationId();\n    \n    try {\n      if (!this.connected) {\n        throw new Error('Not connected to RIS');\n      }\n      \n      await this.simulateLatency();\n      \n      if (this.shouldSimulateError()) {\n        throw new Error('Report creation failed');\n      }\n      \n      const reportID = `RPT_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;\n      \n      const newReport: Report = {\n        reportID,\n        accessionNumber: report.accessionNumber || '',\n        studyInstanceUID: report.studyInstanceUID,\n        patientID: report.patientID || '',\n        reportType: report.reportType || 'PRELIMINARY',\n        status: report.status || 'DRAFT',\n        radiologist: report.radiologist || {\n          id: 'RAD001',\n          name: 'Dr. Test Radiologist',\n          credentials: 'MD',\n          department: 'Radiology'\n        },\n        dictationDate: new Date().toISOString(),\n        findings: report.findings || '',\n        impression: report.impression || '',\n        recommendations: report.recommendations,\n        template: report.template,\n        priorStudyComparison: report.priorStudyComparison,\n        criticalResults: report.criticalResults || false\n      };\n      \n      this.mockReports.push(newReport);\n      \n      // Trigger new report event\n      if (this.onNewReport) {\n        setTimeout(() => {\n          this.onNewReport!(newReport);\n        }, 100);\n      }\n      \n      return this.createSuccessResult(reportID, operationId);\n      \n    } catch (error) {\n      return this.createErrorResult(error.message, 'REPORT_CREATE_FAILED', operationId);\n    }\n  }\n  \n  async updateReport(reportID: string, report: Partial<Report>): Promise<RISOperationResult<boolean>> {\n    const operationId = this.generateOperationId();\n    \n    try {\n      if (!this.connected) {\n        throw new Error('Not connected to RIS');\n      }\n      \n      await this.simulateLatency();\n      \n      if (this.shouldSimulateError()) {\n        throw new Error('Report update failed');\n      }\n      \n      const existingReport = this.mockReports.find(r => r.reportID === reportID);\n      if (existingReport) {\n        Object.assign(existingReport, report);\n        \n        // Trigger report update event\n        if (this.onReportUpdate) {\n          setTimeout(() => {\n            this.onReportUpdate!(reportID, existingReport.status);\n          }, 100);\n        }\n      }\n      \n      return this.createSuccessResult(true, operationId);\n      \n    } catch (error) {\n      return this.createErrorResult(error.message, 'REPORT_UPDATE_FAILED', operationId);\n    }\n  }\n  \n  async signReport(reportID: string, signature: string): Promise<RISOperationResult<boolean>> {\n    const operationId = this.generateOperationId();\n    \n    try {\n      if (!this.connected) {\n        throw new Error('Not connected to RIS');\n      }\n      \n      await this.simulateLatency();\n      \n      if (this.shouldSimulateError()) {\n        throw new Error('Report signing failed');\n      }\n      \n      const report = this.mockReports.find(r => r.reportID === reportID);\n      if (report) {\n        report.status = 'SIGNED';\n        report.signedDate = new Date().toISOString();\n        \n        // Trigger report update event\n        if (this.onReportUpdate) {\n          setTimeout(() => {\n            this.onReportUpdate!(reportID, 'SIGNED');\n          }, 100);\n        }\n      }\n      \n      return this.createSuccessResult(true, operationId);\n      \n    } catch (error) {\n      return this.createErrorResult(error.message, 'REPORT_SIGN_FAILED', operationId);\n    }\n  }\n  \n  async getSchedule(date: string, modality?: string): Promise<RISOperationResult<Schedule[]>> {\n    const operationId = this.generateOperationId();\n    \n    try {\n      if (!this.connected) {\n        throw new Error('Not connected to RIS');\n      }\n      \n      await this.simulateLatency();\n      \n      if (this.shouldSimulateError()) {\n        throw new Error('Schedule retrieval failed');\n      }\n      \n      let results = this.mockSchedule.filter(appointment => {\n        if (appointment.scheduledDate !== date) {\n          return false;\n        }\n        \n        if (modality && appointment.modality !== modality) {\n          return false;\n        }\n        \n        return true;\n      });\n      \n      return this.createSuccessResult(results, operationId);\n      \n    } catch (error) {\n      return this.createErrorResult(error.message, 'SCHEDULE_GET_FAILED', operationId);\n    }\n  }\n  \n  async createAppointment(schedule: Omit<Schedule, 'scheduleID'>): Promise<RISOperationResult<string>> {\n    const operationId = this.generateOperationId();\n    \n    try {\n      if (!this.connected) {\n        throw new Error('Not connected to RIS');\n      }\n      \n      await this.simulateLatency();\n      \n      if (this.shouldSimulateError()) {\n        throw new Error('Appointment creation failed');\n      }\n      \n      const scheduleID = `SCH_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;\n      \n      const newAppointment: Schedule = {\n        ...schedule,\n        scheduleID\n      };\n      \n      this.mockSchedule.push(newAppointment);\n      \n      return this.createSuccessResult(scheduleID, operationId);\n      \n    } catch (error) {\n      return this.createErrorResult(error.message, 'APPOINTMENT_CREATE_FAILED', operationId);\n    }\n  }\n  \n  async updateAppointment(scheduleID: string, updates: Partial<Schedule>): Promise<RISOperationResult<boolean>> {\n    const operationId = this.generateOperationId();\n    \n    try {\n      if (!this.connected) {\n        throw new Error('Not connected to RIS');\n      }\n      \n      await this.simulateLatency();\n      \n      if (this.shouldSimulateError()) {\n        throw new Error('Appointment update failed');\n      }\n      \n      const appointment = this.mockSchedule.find(s => s.scheduleID === scheduleID);\n      if (appointment) {\n        Object.assign(appointment, updates);\n      }\n      \n      return this.createSuccessResult(true, operationId);\n      \n    } catch (error) {\n      return this.createErrorResult(error.message, 'APPOINTMENT_UPDATE_FAILED', operationId);\n    }\n  }\n  \n  async cancelAppointment(scheduleID: string, reason: string): Promise<RISOperationResult<boolean>> {\n    const operationId = this.generateOperationId();\n    \n    try {\n      if (!this.connected) {\n        throw new Error('Not connected to RIS');\n      }\n      \n      await this.simulateLatency();\n      \n      if (this.shouldSimulateError()) {\n        throw new Error('Appointment cancellation failed');\n      }\n      \n      const appointment = this.mockSchedule.find(s => s.scheduleID === scheduleID);\n      if (appointment) {\n        appointment.status = 'CANCELLED';\n        appointment.notes = `Cancelled: ${reason}`;\n      }\n      \n      return this.createSuccessResult(true, operationId);\n      \n    } catch (error) {\n      return this.createErrorResult(error.message, 'APPOINTMENT_CANCEL_FAILED', operationId);\n    }\n  }\n  \n  async sendHL7Message(message: HL7Message): Promise<RISOperationResult<HL7Message>> {\n    const operationId = this.generateOperationId();\n    \n    try {\n      if (!this.connected) {\n        throw new Error('Not connected to RIS');\n      }\n      \n      await this.simulateLatency();\n      \n      if (this.shouldSimulateError()) {\n        throw new Error('HL7 message send failed');\n      }\n      \n      // Create mock ACK message\n      const ackMessage: HL7Message = {\n        messageType: 'ACK',\n        messageControlId: this.generateMessageControlId(),\n        timestamp: new Date().toISOString(),\n        sendingApplication: 'MOCK_RIS',\n        receivingApplication: message.sendingApplication,\n        segments: [\n          {\n            segmentType: 'MSA',\n            fields: ['AA', message.messageControlId, 'Message accepted']\n          }\n        ]\n      };\n      \n      return this.createSuccessResult(ackMessage, operationId, ackMessage.messageControlId);\n      \n    } catch (error) {\n      return this.createErrorResult(error.message, 'HL7_SEND_FAILED', operationId);\n    }\n  }\n  \n  async parseHL7Message(rawMessage: string): Promise<RISOperationResult<HL7Message>> {\n    const operationId = this.generateOperationId();\n    \n    try {\n      // Simple mock HL7 parsing\n      const lines = rawMessage.split('\\r');\n      const mshLine = lines[0];\n      \n      if (!mshLine.startsWith('MSH')) {\n        throw new Error('Invalid HL7 message format');\n      }\n      \n      const fields = mshLine.split('|');\n      \n      const message: HL7Message = {\n        messageType: fields[9] || '',\n        messageControlId: fields[10] || '',\n        timestamp: fields[7] || '',\n        sendingApplication: fields[3] || '',\n        receivingApplication: fields[5] || '',\n        segments: []\n      };\n      \n      return this.createSuccessResult(message, operationId);\n      \n    } catch (error) {\n      return this.createErrorResult(error.message, 'HL7_PARSE_FAILED', operationId);\n    }\n  }\n  \n  async getStatus(): Promise<RISOperationResult<any>> {\n    const operationId = this.generateOperationId();\n    \n    try {\n      const status = {\n        connected: this.connected,\n        uptime: this.connectionStartTime ? Date.now() - this.connectionStartTime.getTime() : 0,\n        patientCount: this.mockPatients.length,\n        orderCount: this.mockOrders.length,\n        reportCount: this.mockReports.length,\n        scheduleCount: this.mockSchedule.length,\n        mockConfiguration: this.mockConfig,\n        capabilities: [\n          'Patient Management',\n          'Order Management', \n          'Report Management',\n          'Schedule Management',\n          'HL7 Messaging'\n        ],\n        lastActivity: new Date()\n      };\n      \n      return this.createSuccessResult(status, operationId);\n      \n    } catch (error) {\n      return this.createErrorResult(error.message, 'STATUS_ERROR', operationId);\n    }\n  }\n  \n  async getStatistics(): Promise<RISOperationResult<any>> {\n    const operationId = this.generateOperationId();\n    \n    try {\n      const stats = {\n        totalQueries: this.getRandomNumber(500, 2000),\n        totalOrderUpdates: this.getRandomNumber(100, 500),\n        totalReports: this.mockReports.length,\n        averageResponseTime: this.getRandomNumber(150, 800),\n        errorRate: this.mockConfig.errorRate,\n        connectionUptime: this.connectionStartTime ? Date.now() - this.connectionStartTime.getTime() : 0,\n        hl7MessagesProcessed: this.getRandomNumber(200, 1000),\n        webhooksDelivered: this.getRandomNumber(50, 200)\n      };\n      \n      return this.createSuccessResult(stats, operationId);\n      \n    } catch (error) {\n      return this.createErrorResult(error.message, 'STATISTICS_ERROR', operationId);\n    }\n  }\n  \n  /**\n   * Mock-specific methods for testing\n   */\n  \n  updateMockConfig(config: Partial<MockRISConfig>): void {\n    this.mockConfig = { ...this.mockConfig, ...config };\n    this.logger.info('Mock RIS configuration updated');\n  }\n  \n  addMockPatient(patient: Patient): void {\n    this.mockPatients.push(patient);\n    this.logger.debug(`Added mock patient: ${patient.patientID}`);\n  }\n  \n  addMockOrder(order: Order): void {\n    this.mockOrders.push(order);\n    this.logger.debug(`Added mock order: ${order.orderID}`);\n    \n    // Trigger new order event\n    if (this.onNewOrder) {\n      setTimeout(() => {\n        this.onNewOrder!(order);\n      }, 100);\n    }\n  }\n  \n  addMockReport(report: Report): void {\n    this.mockReports.push(report);\n    this.logger.debug(`Added mock report: ${report.reportID}`);\n  }\n  \n  addMockSchedule(schedule: Schedule): void {\n    this.mockSchedule.push(schedule);\n    this.logger.debug(`Added mock schedule: ${schedule.scheduleID}`);\n  }\n  \n  clearMockData(): void {\n    this.mockPatients = [];\n    this.mockOrders = [];\n    this.mockReports = [];\n    this.mockSchedule = [];\n    this.logger.info('Mock data cleared');\n  }\n  \n  simulateConnectionLoss(): void {\n    this.connected = false;\n    if (this.onConnectionLost) {\n      this.onConnectionLost(new Error('Simulated connection loss'));\n    }\n  }\n  \n  simulateNewOrder(patientID: string): void {\n    const order = this.createMockOrder(patientID);\n    this.mockOrders.push(order);\n    \n    if (this.onNewOrder) {\n      this.onNewOrder(order);\n    }\n  }\n  \n  simulateOrderStatusChange(orderID: string, newStatus: string): void {\n    const order = this.mockOrders.find(o => o.orderID === orderID);\n    if (order) {\n      order.status = newStatus as any;\n      \n      if (this.onOrderUpdate) {\n        this.onOrderUpdate(orderID, newStatus);\n      }\n    }\n  }\n  \n  /**\n   * Private helper methods\n   */\n  \n  private async simulateLatency(minMs?: number, maxMs?: number): Promise<void> {\n    if (!this.mockConfig.simulateLatency) {\n      return;\n    }\n    \n    const min = minMs || this.mockConfig.latencyRange.min;\n    const max = maxMs || this.mockConfig.latencyRange.max;\n    \n    const latency = this.getRandomNumber(min, max);\n    await new Promise(resolve => setTimeout(resolve, latency));\n  }\n  \n  private shouldSimulateError(): boolean {\n    return Math.random() < this.mockConfig.errorRate;\n  }\n  \n  private getRandomNumber(min: number, max: number): number {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n  \n  private generateMessageControlId(): string {\n    const sequence = this.messageSequence.toString().padStart(6, '0');\n    this.messageSequence++;\n    return `MOCK${Date.now().toString().slice(-6)}${sequence}`;\n  }\n  \n  private startWorkflowSimulation(): void {\n    if (!this.mockConfig.simulateWorkflowUpdates) {\n      return;\n    }\n    \n    // Simulate periodic workflow updates\n    setInterval(() => {\n      if (this.connected && this.mockOrders.length > 0) {\n        const randomOrder = this.mockOrders[Math.floor(Math.random() * this.mockOrders.length)];\n        const statuses = ['SCHEDULED', 'IN_PROGRESS', 'COMPLETED'];\n        const newStatus = statuses[Math.floor(Math.random() * statuses.length)];\n        \n        if (randomOrder.status !== newStatus) {\n          this.simulateOrderStatusChange(randomOrder.orderID, newStatus);\n        }\n      }\n      \n      // Occasionally simulate new reports\n      if (this.mockConfig.generateReports && Math.random() < 0.3 && this.mockOrders.length > 0) {\n        const completedOrders = this.mockOrders.filter(o => o.status === 'COMPLETED');\n        if (completedOrders.length > 0) {\n          const order = completedOrders[Math.floor(Math.random() * completedOrders.length)];\n          const report = this.createMockReport(order.accessionNumber, order.patientID);\n          this.mockReports.push(report);\n          \n          if (this.onNewReport) {\n            this.onNewReport(report);\n          }\n        }\n      }\n    }, 30000); // Every 30 seconds\n  }\n  \n  private initializeMockData(): void {\n    switch (this.mockConfig.mockDataSet) {\n      case 'minimal':\n        this.createMinimalDataSet();\n        break;\n      case 'comprehensive':\n        this.createComprehensiveDataSet();\n        break;\n      case 'large':\n        this.createLargeDataSet();\n        break;\n    }\n  }\n  \n  private createMinimalDataSet(): void {\n    // Create 5 patients with basic data\n    for (let i = 1; i <= 5; i++) {\n      const patient = this.createMockPatient(i);\n      this.mockPatients.push(patient);\n      \n      // Create 1-2 orders per patient\n      const orderCount = this.getRandomNumber(1, 2);\n      for (let j = 1; j <= orderCount; j++) {\n        const order = this.createMockOrder(patient.patientID, j);\n        this.mockOrders.push(order);\n        \n        // Create appointments\n        const schedule = this.createMockSchedule(order);\n        this.mockSchedule.push(schedule);\n        \n        // Create reports for completed orders\n        if (order.status === 'COMPLETED') {\n          const report = this.createMockReport(order.accessionNumber, patient.patientID);\n          this.mockReports.push(report);\n        }\n      }\n    }\n  }\n  \n  private createComprehensiveDataSet(): void {\n    // Create 25 patients with comprehensive data\n    const modalities = ['CT', 'MR', 'XR', 'US', 'NM', 'PT', 'MG'];\n    const priorities = ['STAT', 'URGENT', 'ROUTINE'] as const;\n    const statuses = ['SCHEDULED', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED'] as const;\n    \n    for (let i = 1; i <= 25; i++) {\n      const patient = this.createMockPatient(i);\n      this.mockPatients.push(patient);\n      \n      const orderCount = this.getRandomNumber(1, 4);\n      for (let j = 1; j <= orderCount; j++) {\n        const order = this.createMockOrder(\n          patient.patientID,\n          j,\n          modalities[j % modalities.length],\n          priorities[j % priorities.length],\n          statuses[j % statuses.length]\n        );\n        this.mockOrders.push(order);\n        \n        const schedule = this.createMockSchedule(order);\n        this.mockSchedule.push(schedule);\n        \n        if (order.status === 'COMPLETED') {\n          const report = this.createMockReport(order.accessionNumber, patient.patientID);\n          this.mockReports.push(report);\n        }\n      }\n    }\n  }\n  \n  private createLargeDataSet(): void {\n    // Create 100 patients for performance testing\n    const modalities = ['CT', 'MR', 'XR', 'US', 'NM', 'PT', 'MG', 'RF', 'CR', 'DX'];\n    const priorities = ['STAT', 'URGENT', 'ROUTINE'] as const;\n    const statuses = ['SCHEDULED', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED'] as const;\n    \n    for (let i = 1; i <= 100; i++) {\n      const patient = this.createMockPatient(i);\n      this.mockPatients.push(patient);\n      \n      const orderCount = this.getRandomNumber(2, 6);\n      for (let j = 1; j <= orderCount; j++) {\n        const order = this.createMockOrder(\n          patient.patientID,\n          j,\n          modalities[j % modalities.length],\n          priorities[j % priorities.length],\n          statuses[j % statuses.length]\n        );\n        this.mockOrders.push(order);\n        \n        const schedule = this.createMockSchedule(order);\n        this.mockSchedule.push(schedule);\n        \n        if (order.status === 'COMPLETED' && Math.random() < 0.8) {\n          const report = this.createMockReport(order.accessionNumber, patient.patientID);\n          this.mockReports.push(report);\n        }\n      }\n    }\n  }\n  \n  private createMockPatient(index: number): Patient {\n    const names = [\n      'Smith', 'Johnson', 'Williams', 'Brown', 'Jones', 'Garcia', 'Miller', 'Davis', 'Rodriguez', 'Martinez'\n    ];\n    const firstNames = [\n      'John', 'Jane', 'Michael', 'Sarah', 'David', 'Emily', 'Robert', 'Lisa', 'James', 'Maria'\n    ];\n    \n    const birthDate = new Date();\n    birthDate.setFullYear(birthDate.getFullYear() - this.getRandomNumber(25, 80));\n    \n    return {\n      patientID: `PAT${index.toString().padStart(4, '0')}`,\n      mrn: `MRN${index.toString().padStart(6, '0')}`,\n      firstName: firstNames[index % firstNames.length],\n      lastName: names[index % names.length],\n      dateOfBirth: birthDate.toISOString().split('T')[0],\n      gender: index % 2 === 0 ? 'M' : 'F',\n      address: {\n        street: `${this.getRandomNumber(100, 9999)} Main St`,\n        city: 'Sydney',\n        state: 'NSW',\n        postalCode: `20${this.getRandomNumber(10, 99)}`,\n        country: 'Australia'\n      },\n      phoneNumber: `02-${this.getRandomNumber(1000, 9999)}-${this.getRandomNumber(1000, 9999)}`,\n      email: `patient${index}@example.com`\n    };\n  }\n  \n  private createMockOrder(\n    patientID: string,\n    index: number = 1,\n    modality: string = 'CT',\n    priority: 'STAT' | 'URGENT' | 'ROUTINE' = 'ROUTINE',\n    status: 'SCHEDULED' | 'IN_PROGRESS' | 'COMPLETED' | 'CANCELLED' = 'SCHEDULED'\n  ): Order {\n    const orderDate = new Date();\n    orderDate.setDate(orderDate.getDate() - this.getRandomNumber(0, 30));\n    \n    const scheduledDate = new Date(orderDate);\n    scheduledDate.setDate(scheduledDate.getDate() + this.getRandomNumber(1, 7));\n    \n    return {\n      orderID: `ORD${patientID}_${index}`,\n      accessionNumber: `ACC${Date.now().toString().slice(-8)}_${index}`,\n      patientID,\n      orderDate: orderDate.toISOString(),\n      scheduledDate: scheduledDate.toISOString(),\n      priority,\n      status,\n      orderingPhysician: {\n        id: `DOC${this.getRandomNumber(100, 999)}`,\n        name: `Dr. Ordering^${index}`,\n        department: 'Internal Medicine',\n        contactInfo: `doc${index}@hospital.com`\n      },\n      procedures: [\n        {\n          procedureCode: `PROC_${modality}_${index}`,\n          description: `${modality} Scan`,\n          modality,\n          bodyPart: ['CHEST', 'ABDOMEN', 'HEAD', 'PELVIS'][index % 4],\n          contrast: Math.random() < 0.4,\n          estimatedDuration: this.getRandomNumber(15, 90),\n          status\n        }\n      ],\n      clinicalInfo: `Clinical indication for ${modality} scan`,\n      reason: 'Diagnostic imaging',\n      urgency: priority\n    };\n  }\n  \n  private createMockReport(accessionNumber: string, patientID: string): Report {\n    const reportTypes = ['PRELIMINARY', 'FINAL', 'ADDENDUM'] as const;\n    const statuses = ['DRAFT', 'PENDING', 'VERIFIED', 'SIGNED'] as const;\n    \n    return {\n      reportID: `RPT_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`,\n      accessionNumber,\n      patientID,\n      reportType: reportTypes[Math.floor(Math.random() * reportTypes.length)],\n      status: statuses[Math.floor(Math.random() * statuses.length)],\n      radiologist: {\n        id: `RAD${this.getRandomNumber(100, 999)}`,\n        name: `Dr. Radiologist^${this.getRandomNumber(1, 10)}`,\n        credentials: 'MD, FRANZCR',\n        department: 'Diagnostic Radiology'\n      },\n      dictationDate: new Date().toISOString(),\n      findings: 'Mock findings for testing purposes. This is a sample radiology report with typical clinical content.',\n      impression: 'Mock impression. Normal study with no acute findings.',\n      recommendations: 'Follow-up as clinically indicated.',\n      criticalResults: Math.random() < 0.1\n    };\n  }\n  \n  private createMockSchedule(order: Order): Schedule {\n    const scheduledDate = order.scheduledDate ? new Date(order.scheduledDate) : new Date();\n    \n    return {\n      scheduleID: `SCH_${order.orderID}`,\n      patientID: order.patientID,\n      orderID: order.orderID,\n      scheduledDate: scheduledDate.toISOString().split('T')[0],\n      scheduledTime: `${this.getRandomNumber(8, 17).toString().padStart(2, '0')}:${['00', '15', '30', '45'][Math.floor(Math.random() * 4)]}`,\n      estimatedDuration: order.procedures[0]?.estimatedDuration || 30,\n      room: `Room ${this.getRandomNumber(1, 10)}`,\n      modality: order.procedures[0]?.modality || 'CT',\n      technologist: `Tech ${this.getRandomNumber(1, 5)}`,\n      status: order.status as any,\n      notes: 'Mock appointment notes'\n    };\n  }\n}"