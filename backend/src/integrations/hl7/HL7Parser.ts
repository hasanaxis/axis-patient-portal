/**
 * HL7 Parser Implementation
 * Parses and validates HL7 v2.x messages
 */

import { HL7Message, HL7Segment } from '../interfaces/IRISProvider';
import { Logger } from '../../utils/logger';

export interface HL7ParseOptions {
  validateStructure?: boolean;
  strictValidation?: boolean;
  customDelimiters?: {
    fieldSeparator?: string;
    componentSeparator?: string;
    repetitionSeparator?: string;
    escapeCharacter?: string;
    subComponentSeparator?: string;
  };
}

export interface HL7ValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
}

export interface HL7Field {
  value: string;
  components: string[];
  repetitions: string[][];
}

export interface ParsedHL7Segment {
  type: string;
  fields: HL7Field[];
  rawFields: string[];
}

export class HL7Parser {
  private logger: Logger;
  
  // Default HL7 delimiters
  private readonly DEFAULT_FIELD_SEPARATOR = '|';
  private readonly DEFAULT_COMPONENT_SEPARATOR = '^';
  private readonly DEFAULT_REPETITION_SEPARATOR = '~';
  private readonly DEFAULT_ESCAPE_CHARACTER = '\\';
  private readonly DEFAULT_SUB_COMPONENT_SEPARATOR = '&';
  private readonly SEGMENT_TERMINATOR = '\r';
  
  constructor() {
    this.logger = new Logger('HL7Parser');
  }
  
  /**
   * Parse HL7 message from raw string
   */
  async parse(rawMessage: string, options: HL7ParseOptions = {}): Promise<HL7Message> {
    try {
      // Clean the message
      const cleanMessage = this.cleanMessage(rawMessage);
      
      // Split into segments
      const segmentLines = this.splitIntoSegments(cleanMessage);
      
      if (segmentLines.length === 0) {
        throw new Error('No segments found in HL7 message');
      }
      
      // Parse MSH segment first to get delimiters
      const mshLine = segmentLines[0];
      if (!mshLine.startsWith('MSH')) {\n        throw new Error('HL7 message must start with MSH segment');\n      }\n      \n      const delimiters = this.extractDelimiters(mshLine, options.customDelimiters);\n      const mshSegment = this.parseMSHSegment(mshLine, delimiters);\n      \n      // Extract message metadata from MSH\n      const messageType = this.getFieldValue(mshSegment, 9) || '';\n      const messageControlId = this.getFieldValue(mshSegment, 10) || '';\n      const timestamp = this.getFieldValue(mshSegment, 7) || '';\n      const sendingApplication = this.getFieldValue(mshSegment, 3) || '';\n      const receivingApplication = this.getFieldValue(mshSegment, 5) || '';\n      \n      // Parse remaining segments\n      const segments: HL7Segment[] = [];\n      \n      for (let i = 1; i < segmentLines.length; i++) {\n        const segment = this.parseSegment(segmentLines[i], delimiters);\n        segments.push({\n          segmentType: segment.type,\n          fields: segment.rawFields\n        });\n      }\n      \n      const message: HL7Message = {\n        messageType,\n        messageControlId,\n        timestamp,\n        sendingApplication,\n        receivingApplication,\n        segments\n      };\n      \n      // Validate message if requested\n      if (options.validateStructure) {\n        const validation = this.validateMessage(message, options.strictValidation);\n        if (!validation.isValid && options.strictValidation) {\n          throw new Error(`HL7 validation failed: ${validation.errors.join(', ')}`);\n        }\n        \n        if (validation.warnings.length > 0) {\n          this.logger.warn('HL7 validation warnings:', validation.warnings);\n        }\n      }\n      \n      return message;\n      \n    } catch (error) {\n      this.logger.error('HL7 parsing failed:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Validate HL7 message structure\n   */\n  validateMessage(message: HL7Message, strict: boolean = false): HL7ValidationResult {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n    \n    // Check required fields\n    if (!message.messageType) {\n      errors.push('Message type is required');\n    }\n    \n    if (!message.messageControlId) {\n      errors.push('Message control ID is required');\n    }\n    \n    if (!message.sendingApplication) {\n      warnings.push('Sending application is missing');\n    }\n    \n    if (!message.receivingApplication) {\n      warnings.push('Receiving application is missing');\n    }\n    \n    // Validate message type format\n    if (message.messageType && !message.messageType.includes('^')) {\n      warnings.push('Message type should include trigger event (e.g., ADT^A01)');\n    }\n    \n    // Check for required segments based on message type\n    const messageTypeCode = message.messageType.split('^')[0];\n    const requiredSegments = this.getRequiredSegments(messageTypeCode);\n    \n    requiredSegments.forEach(segmentType => {\n      const hasSegment = message.segments.some(seg => seg.segmentType === segmentType);\n      if (!hasSegment) {\n        if (strict) {\n          errors.push(`Required segment ${segmentType} is missing`);\n        } else {\n          warnings.push(`Recommended segment ${segmentType} is missing`);\n        }\n      }\n    });\n    \n    // Validate segment structure\n    message.segments.forEach((segment, index) => {\n      if (!segment.segmentType) {\n        errors.push(`Segment ${index} is missing segment type`);\n      }\n      \n      if (!Array.isArray(segment.fields)) {\n        errors.push(`Segment ${segment.segmentType} has invalid fields structure`);\n      }\n    });\n    \n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings\n    };\n  }\n  \n  /**\n   * Extract specific field value from HL7 message\n   */\n  getFieldValue(segment: ParsedHL7Segment, fieldIndex: number, componentIndex?: number): string | undefined {\n    if (fieldIndex >= segment.fields.length) {\n      return undefined;\n    }\n    \n    const field = segment.fields[fieldIndex];\n    \n    if (componentIndex !== undefined) {\n      if (componentIndex >= field.components.length) {\n        return undefined;\n      }\n      return field.components[componentIndex];\n    }\n    \n    return field.value;\n  }\n  \n  /**\n   * Extract patient information from HL7 message\n   */\n  extractPatientInfo(message: HL7Message): any {\n    const pidSegment = message.segments.find(seg => seg.segmentType === 'PID');\n    \n    if (!pidSegment) {\n      return null;\n    }\n    \n    // Parse PID segment fields\n    const patientID = pidSegment.fields[2] || '';\n    const patientName = pidSegment.fields[4] || '';\n    const dateOfBirth = pidSegment.fields[6] || '';\n    const gender = pidSegment.fields[7] || '';\n    const address = pidSegment.fields[10] || '';\n    const phoneNumber = pidSegment.fields[12] || '';\n    \n    return {\n      patientID: this.parsePatientID(patientID),\n      name: this.parsePatientName(patientName),\n      dateOfBirth: this.parseDate(dateOfBirth),\n      gender: gender.charAt(0),\n      address: this.parseAddress(address),\n      phoneNumber: this.parsePhoneNumber(phoneNumber)\n    };\n  }\n  \n  /**\n   * Extract order information from HL7 message\n   */\n  extractOrderInfo(message: HL7Message): any {\n    const obrSegment = message.segments.find(seg => seg.segmentType === 'OBR');\n    const orcSegment = message.segments.find(seg => seg.segmentType === 'ORC');\n    \n    if (!obrSegment) {\n      return null;\n    }\n    \n    const orderControlCode = orcSegment?.fields[0] || '';\n    const placerOrderNumber = orcSegment?.fields[1] || '';\n    const fillerOrderNumber = orcSegment?.fields[2] || '';\n    const universalServiceID = obrSegment.fields[3] || '';\n    const observationDateTime = obrSegment.fields[6] || '';\n    const orderingProvider = obrSegment.fields[15] || '';\n    \n    return {\n      orderControlCode,\n      placerOrderNumber,\n      fillerOrderNumber,\n      serviceID: this.parseServiceID(universalServiceID),\n      observationDateTime: this.parseDateTime(observationDateTime),\n      orderingProvider: this.parseProvider(orderingProvider)\n    };\n  }\n  \n  /**\n   * Extract report information from HL7 message\n   */\n  extractReportInfo(message: HL7Message): any {\n    const obxSegments = message.segments.filter(seg => seg.segmentType === 'OBX');\n    \n    if (obxSegments.length === 0) {\n      return null;\n    }\n    \n    const observations = obxSegments.map(segment => {\n      const setID = segment.fields[0] || '';\n      const valueType = segment.fields[1] || '';\n      const observationID = segment.fields[2] || '';\n      const observationValue = segment.fields[4] || '';\n      const units = segment.fields[5] || '';\n      const referenceRange = segment.fields[6] || '';\n      const abnormalFlags = segment.fields[7] || '';\n      const observationResultStatus = segment.fields[10] || '';\n      \n      return {\n        setID,\n        valueType,\n        observationID: this.parseObservationID(observationID),\n        value: observationValue,\n        units,\n        referenceRange,\n        abnormalFlags,\n        status: observationResultStatus\n      };\n    });\n    \n    return {\n      observations,\n      reportCount: observations.length\n    };\n  }\n  \n  /**\n   * Generate HL7 message string from message object\n   */\n  generate(message: HL7Message, options: HL7ParseOptions = {}): string {\n    const delimiters = {\n      fieldSeparator: options.customDelimiters?.fieldSeparator || this.DEFAULT_FIELD_SEPARATOR,\n      componentSeparator: options.customDelimiters?.componentSeparator || this.DEFAULT_COMPONENT_SEPARATOR,\n      repetitionSeparator: options.customDelimiters?.repetitionSeparator || this.DEFAULT_REPETITION_SEPARATOR,\n      escapeCharacter: options.customDelimiters?.escapeCharacter || this.DEFAULT_ESCAPE_CHARACTER,\n      subComponentSeparator: options.customDelimiters?.subComponentSeparator || this.DEFAULT_SUB_COMPONENT_SEPARATOR\n    };\n    \n    // Build MSH segment\n    const mshSegment = this.generateMSHSegment(message, delimiters);\n    \n    // Build other segments\n    const segmentStrings = [mshSegment];\n    \n    message.segments.forEach(segment => {\n      const segmentString = this.generateSegmentString(segment, delimiters);\n      segmentStrings.push(segmentString);\n    });\n    \n    return segmentStrings.join(this.SEGMENT_TERMINATOR) + this.SEGMENT_TERMINATOR;\n  }\n  \n  /**\n   * Private helper methods\n   */\n  \n  private cleanMessage(rawMessage: string): string {\n    // Remove message wrapper characters if present\n    let cleaned = rawMessage.replace(/\\x0b|\\x1c/g, '');\n    \n    // Normalize line endings\n    cleaned = cleaned.replace(/\\r\\n|\\n/g, this.SEGMENT_TERMINATOR);\n    \n    return cleaned.trim();\n  }\n  \n  private splitIntoSegments(message: string): string[] {\n    return message.split(this.SEGMENT_TERMINATOR).filter(line => line.trim());\n  }\n  \n  private extractDelimiters(mshLine: string, customDelimiters?: any): any {\n    // MSH|^~\\&|...\n    const fieldSeparator = mshLine.charAt(3) || this.DEFAULT_FIELD_SEPARATOR;\n    const encodingChars = mshLine.substring(4, 8);\n    \n    return {\n      fieldSeparator: customDelimiters?.fieldSeparator || fieldSeparator,\n      componentSeparator: customDelimiters?.componentSeparator || encodingChars.charAt(0) || this.DEFAULT_COMPONENT_SEPARATOR,\n      repetitionSeparator: customDelimiters?.repetitionSeparator || encodingChars.charAt(1) || this.DEFAULT_REPETITION_SEPARATOR,\n      escapeCharacter: customDelimiters?.escapeCharacter || encodingChars.charAt(2) || this.DEFAULT_ESCAPE_CHARACTER,\n      subComponentSeparator: customDelimiters?.subComponentSeparator || encodingChars.charAt(3) || this.DEFAULT_SUB_COMPONENT_SEPARATOR\n    };\n  }\n  \n  private parseMSHSegment(mshLine: string, delimiters: any): ParsedHL7Segment {\n    // MSH segment has special structure: MSH|^~\\&|field3|field4|...\n    const fields = mshLine.split(delimiters.fieldSeparator);\n    \n    // Reconstruct fields with proper indexing\n    const reconstructedFields = [\n      fields[0], // MSH\n      delimiters.fieldSeparator, // Field separator\n      fields[1].substring(1), // Encoding characters (remove field separator)\n      ...fields.slice(2) // Remaining fields\n    ];\n    \n    return this.parseSegmentFields(reconstructedFields, delimiters);\n  }\n  \n  private parseSegment(segmentLine: string, delimiters: any): ParsedHL7Segment {\n    const fields = segmentLine.split(delimiters.fieldSeparator);\n    return this.parseSegmentFields(fields, delimiters);\n  }\n  \n  private parseSegmentFields(fields: string[], delimiters: any): ParsedHL7Segment {\n    const segmentType = fields[0];\n    const parsedFields: HL7Field[] = [];\n    const rawFields: string[] = [];\n    \n    for (let i = 1; i < fields.length; i++) {\n      const fieldValue = fields[i] || '';\n      rawFields.push(fieldValue);\n      \n      // Parse components and repetitions\n      const repetitions = fieldValue.split(delimiters.repetitionSeparator);\n      const parsedRepetitions: string[][] = [];\n      \n      repetitions.forEach(repetition => {\n        const components = repetition.split(delimiters.componentSeparator);\n        parsedRepetitions.push(components);\n      });\n      \n      parsedFields.push({\n        value: fieldValue,\n        components: repetitions[0] ? repetitions[0].split(delimiters.componentSeparator) : [],\n        repetitions: parsedRepetitions\n      });\n    }\n    \n    return {\n      type: segmentType,\n      fields: parsedFields,\n      rawFields\n    };\n  }\n  \n  private getRequiredSegments(messageType: string): string[] {\n    const segmentMap: Record<string, string[]> = {\n      'ADT': ['PID'],\n      'ORM': ['PID', 'ORC', 'OBR'],\n      'ORU': ['PID', 'OBR', 'OBX'],\n      'QRY': ['QRD'],\n      'SIU': ['SCH', 'PID'],\n      'MDM': ['PID', 'TXA']\n    };\n    \n    return segmentMap[messageType] || [];\n  }\n  \n  private parsePatientID(patientIDField: string): string {\n    // Patient ID is typically in format: ID^^^&OID&ISO\n    return patientIDField.split('^')[0] || '';\n  }\n  \n  private parsePatientName(nameField: string): any {\n    // Patient name format: LastName^FirstName^MiddleName^Suffix^Prefix\n    const components = nameField.split('^');\n    \n    return {\n      lastName: components[0] || '',\n      firstName: components[1] || '',\n      middleName: components[2] || '',\n      suffix: components[3] || '',\n      prefix: components[4] || ''\n    };\n  }\n  \n  private parseDate(dateField: string): string {\n    // HL7 date format: YYYYMMDD or YYYYMMDDHHMMSS\n    if (dateField.length >= 8) {\n      const year = dateField.substring(0, 4);\n      const month = dateField.substring(4, 6);\n      const day = dateField.substring(6, 8);\n      \n      return `${year}-${month}-${day}`;\n    }\n    \n    return dateField;\n  }\n  \n  private parseDateTime(dateTimeField: string): string {\n    // HL7 datetime format: YYYYMMDDHHMMSS\n    if (dateTimeField.length >= 14) {\n      const year = dateTimeField.substring(0, 4);\n      const month = dateTimeField.substring(4, 6);\n      const day = dateTimeField.substring(6, 8);\n      const hour = dateTimeField.substring(8, 10);\n      const minute = dateTimeField.substring(10, 12);\n      const second = dateTimeField.substring(12, 14);\n      \n      return `${year}-${month}-${day}T${hour}:${minute}:${second}`;\n    }\n    \n    return this.parseDate(dateTimeField);\n  }\n  \n  private parseAddress(addressField: string): any {\n    // Address format: Street^OtherDesignation^City^State^Zip^Country\n    const components = addressField.split('^');\n    \n    return {\n      street: components[0] || '',\n      otherDesignation: components[1] || '',\n      city: components[2] || '',\n      state: components[3] || '',\n      postalCode: components[4] || '',\n      country: components[5] || ''\n    };\n  }\n  \n  private parsePhoneNumber(phoneField: string): string {\n    // Phone format: (999)999-9999X99999^PRN^PH\n    const components = phoneField.split('^');\n    return components[0] || '';\n  }\n  \n  private parseServiceID(serviceField: string): any {\n    // Service ID format: Code^Text^CodingSystem\n    const components = serviceField.split('^');\n    \n    return {\n      code: components[0] || '',\n      text: components[1] || '',\n      codingSystem: components[2] || ''\n    };\n  }\n  \n  private parseProvider(providerField: string): any {\n    // Provider format: ID^LastName^FirstName^MiddleName^Suffix^Prefix^Degree\n    const components = providerField.split('^');\n    \n    return {\n      id: components[0] || '',\n      lastName: components[1] || '',\n      firstName: components[2] || '',\n      middleName: components[3] || '',\n      suffix: components[4] || '',\n      prefix: components[5] || '',\n      degree: components[6] || ''\n    };\n  }\n  \n  private parseObservationID(obsField: string): any {\n    // Observation ID format: Code^Text^CodingSystem\n    const components = obsField.split('^');\n    \n    return {\n      code: components[0] || '',\n      text: components[1] || '',\n      codingSystem: components[2] || ''\n    };\n  }\n  \n  private generateMSHSegment(message: HL7Message, delimiters: any): string {\n    const encodingChars = delimiters.componentSeparator +\n      delimiters.repetitionSeparator +\n      delimiters.escapeCharacter +\n      delimiters.subComponentSeparator;\n    \n    const fields = [\n      'MSH',\n      delimiters.fieldSeparator + encodingChars,\n      message.sendingApplication,\n      '', // Sending facility\n      message.receivingApplication,\n      '', // Receiving facility\n      this.formatTimestamp(new Date()),\n      '', // Security\n      message.messageType,\n      message.messageControlId,\n      'P', // Processing ID\n      '2.5' // Version ID\n    ];\n    \n    return fields.join(delimiters.fieldSeparator);\n  }\n  \n  private generateSegmentString(segment: HL7Segment, delimiters: any): string {\n    const fields = [segment.segmentType, ...segment.fields];\n    return fields.join(delimiters.fieldSeparator);\n  }\n  \n  private formatTimestamp(date: Date): string {\n    const year = date.getFullYear();\n    const month = (date.getMonth() + 1).toString().padStart(2, '0');\n    const day = date.getDate().toString().padStart(2, '0');\n    const hour = date.getHours().toString().padStart(2, '0');\n    const minute = date.getMinutes().toString().padStart(2, '0');\n    const second = date.getSeconds().toString().padStart(2, '0');\n    \n    return `${year}${month}${day}${hour}${minute}${second}`;\n  }\n}"